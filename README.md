# JobExecutor2

Σωτήριος Σκανδάλης 1115202000181

## Γενικά

Στην εργασία αυτή χρησιμοποιώ μια δομη ενος clockwise buffer, οπου για την λειτουργια του υπάρχει ένας δείκτης in και ένας δείκτης out (που πρεπει να εισαχθούν δεδομένα και που να εξαχθούν), ενα mutex και 2 condition variables (full/empty). Υπάρχει επίσης ένα ακόμα mutex και condition variable για να αλλάζει η παραλληλία (concurrency). Ο server κατα την εκκινηση του αρχικοποιει τους worker threads με βαση το threadPoolSize και αφου ανοίξει και περιμένει για συνδέσεις σε μία θύρα, μπλοκαρει στην κλήση accept, και ξεμπλοκαρει ανάλογα αν έρθει κάποιο request από κάποιον πελάτη. Στην περίπτωση αυτή δημιουργείται ένας controller thread οπου περιέχει όλη την λογική ως προς ποια εντολή ζητήθηκε να εκτελεστεί και τι πρεπει να γινει για να εκτελεστει η εντολη αυτη. Οι worker threads ταυτόχρονα περιμένουν να προστεθεί κάποια δουλειά στον buffer ώστε να αρχίσουν να την εκτελούν αν το επιτρέπει ο βαθμός παραλληλίας.

## Επικοινωνία

Ο server μπορεί να δεχτεί ταυτόχρονα bufferSize εντολές και θα δημιουργηθούν bufferSize controller threads για να διαχειριστουν τα αιτηματα. Για κάθε εντολή επιστρέφει ο controller την απάντηση που αναλογεί όπως στην εκφώνηση. Στην issueJob όμως χρησιμοποιήθηκε το εξής πρωτοκόλλο για να δεχτεί μία εντολή από έναν commander. Πρώτα ο commander στέλνει "issueJob" χωρίς την ίδια την εντολή, και ο server απαντάει με το string "ACK" (Acknoledged). Αφού ο commander δεχθεί το ACK στέλνει το μέγεθος της εντολής που πρόκειται να στείλει. O server απαντάει πίσω με το μέγεθος. O commander ελέγχει οτι το μέγεθος που έλαβε έιναι σωστό, και αν είναι στέλνει όλο το πακέτο με την εντολή (σε κομμάτια αν χρειαστει). 

## Λειτουργία controller-worker threads

Η αλληλεπίδραση των controllers με τους workers γίνεται συνήθως όταν καλείται η εντολή issueJob. Οι workers στους οποίους επιτρέπεται απτον βαθμό παραλληλίας να τρέξουν περιμένουν συνεχώς να γεμίσει ο ενταμιευτής με κάποια εντολή ώστε να την εκτελέσουν, αν δεν υπάρχει, γίνονται blocked με το condition variable isEmpty. Έτσι ανάλογα αν κάποιος controller παει και προσθεσει κάτι στον ενταμιευτή θα κάνει signal την μεταβλητη αυτή ώστε να τρέξει κάποιος worker. Οι controllers μπορούν και αυτοί να βρεθούν ανάλογα σε ένα σενάριο blocking αν ο ενταμιευτής είναι γεμάτος και δεν μπορούν να προσθέσουν την δουλεία που δώθηκε στον ενταμιευτή με το condition variable isFull. Αν δεν είναι full όμως δημιουργούν ένα struct job που περιέχει την ίδια την εντολή, το id της και το socketFileDescriptor για την επικοινωνία με τον συγκεκριμένο πελάτη (το file descriptor της accept δηλαδή όχι της αρχικής σύνδεσης).

## Ανακατεύθυνση εντολών

Ο worker thread αναλαμβάνει εξ ολοκλήρου την εκτέλεση και την ανακατεύθυνση της εντολής στον commander. Πρωτού εκτελέσει μια εντολή, δημιουργεί ένα child process με την εντολή fork και δημιουργει ένα αρχείο pid.output (με το pid του παιδιου), αφού δημιουργήσει το αρχείο, κάνει ανακατεύθυνση της stdout στο αρχείο που δημιούργησε με την εντολή dup2. Αφού γίνουν αυτά η εντολή είναι έτοιμη να εκτελεστεί και καλείται η execvp. Αφού τελειώσει η εντολή και η έξοδος της βρίσκεται στο αρχείο (αν υπάρχει) το parent process διαβάζει το αρχείο και στέλνει στον commander τα περιεχόμενα του σε κομμάτια των 1024 bytes, μέχρι να βρει EOF. Ο commander ανάλογα ενώνει τα κομμάτια και τα εμφανίζει σαν ένα ενιαίο κομμάτι, όπως αν εκτελούσε την εντολή locally.  
